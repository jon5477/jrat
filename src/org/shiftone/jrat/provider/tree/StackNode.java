package org.shiftone.jrat.provider.tree;


import org.shiftone.jrat.core.Accumulator;
import org.shiftone.jrat.core.MethodKey;
import org.shiftone.jrat.provider.tree.ui.TreeOutputXmlViewBuilder;
import org.shiftone.jrat.util.StringUtil;
import org.shiftone.jrat.util.log.Logger;
import org.shiftone.jrat.util.time.Clock;

import java.io.PrintWriter;
import java.io.Externalizable;
import java.io.ObjectOutput;
import java.io.IOException;
import java.io.ObjectInput;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;


/**
 * Class StackNode
 *
 * @author Jeff Drost
 */
public class StackNode extends Accumulator implements Externalizable {

    private static final Logger LOG = Logger.getLogger(StackNode.class);
    public static final String VIEWER = TreeOutputXmlViewBuilder.class.getName();
    protected MethodKey methodKey;
    protected StackNode parent;
    protected HashMap children = new HashMap(3);


    public void writeExternal(ObjectOutput out) throws IOException {
 
        super.writeExternal(out);

        if (methodKey == null) {
            out.writeBoolean(true); // root
        } else {
            out.writeBoolean(false); // root
            methodKey.writeExternal(out);
        }

        // create a copy of the children
        List list = new ArrayList();
        synchronized (children) {
            list.addAll(children.values());
        }

        // write a child count
        out.writeInt(list.size());

        // write the children
        for (int i = 0; i < list.size(); i++) {
            StackNode child = (StackNode) list.get(i);
            child.writeExternal(out);
        }
    }

    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {

        super.readExternal(in);

        if (!in.readBoolean()) { // root
            methodKey.readExternal(in);
        }

        int childCount = in.readInt();
        for (int i = 0; i < childCount; i++) {
            StackNode stackNode = new StackNode();
            stackNode.parent = this;
            stackNode.readExternal(in);
        }

    }

    public StackNode() {

        // root node
        this.methodKey = null;
        this.parent = null;
    }


    public StackNode(MethodKey methodKey, StackNode treeNode) {
        this.methodKey = methodKey;
        this.parent = treeNode;
    }


    /**
     * Method gets <b>AND CREATES IF NEEDED</b> the requested tree node
     */
    public StackNode getChild(MethodKey methodKey) {

        StackNode treeNode = null;

        synchronized (children) {
            treeNode = (StackNode) children.get(methodKey);

            if (treeNode == null) {
                treeNode = new StackNode(methodKey, this);

                children.put(methodKey, treeNode);
            }
        }

        return treeNode;
    }


    public final StackNode getParentNode() {
        return parent;
    }


    public final boolean isRootNode() {
        return (methodKey == null);
    }


    public MethodKey getMethodKey() {
        return methodKey;
    }


    public void printXML(PrintWriter out) {

        LOG.info("printXML...");

        if (isRootNode()) {
            printRoot(out);
        } else {

            // this should never happen
            printNonRoot(out, 0);
        }

        LOG.info("printXML complete.");
        LOG.info("checkError = " + out.checkError());
    }


    private void printRoot(PrintWriter out) {

        long start = Clock.currentTimeNanos();

        LOG.info("printRoot...");
        out.print("<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>");
        out.println("<!-- generated by JRat 'call tree' provider on " + new Date() + "-->");
        out.println("<jrat-tree viewer=\"" + VIEWER + "\">");
        out.println("<view>");
        printChildren(out, 0);
        out.println("</view>");
        out.println("<!-- file written in " + (Clock.currentTimeNanos() - start) + " nanos -->");
        out.println("</jrat-tree>");
        LOG.info("printRoot complete.");
    }


    private void printNonRoot(PrintWriter out, int depth) {

        // out.print(StringUtil.bufferString(depth, ' '));
        out.print("<call");
        out.print(" c=\"" + methodKey.getClassName() + "\"");
        out.print(" m=\"" + methodKey.getMethodName() + "\"");
        out.print(" s=\"" + methodKey.getSignature() + "\"");
        out.print(" ent=\"" + getTotalEnters() + "\"");
        out.print(" xit=\"" + getTotalExits() + "\"");
        out.print(" err=\"" + getTotalErrors() + "\"");
        out.print(" dur=\"" + getTotalDurationNanos() + "\"");
        out.print(" sos=\"" + getSumOfSquares() + "\"");
        out.print(" mct=\"" + getMaxConcurrentThreads() + "\"");

        if (getTotalDurationNanos() != 0) {
            out.print(" min=\"" + getMinDurationNanos() + "\"");
            out.print(" max=\"" + getMaxDurationNanos() + "\"");
        }

        if (children.size() > 0) {
            out.println(">");
            printChildren(out, depth);

            // out.print(StringUtil.bufferString(depth, ' '));
            out.println("</call>");
        } else {
            out.println("/>");
        }

        out.flush();
    }


    private void printChildren(PrintWriter out, int depth) {

        // need to clone map - concurrency issues
        List list = new ArrayList();

        synchronized (children) {
            list.addAll(children.values());
        }

        for (int i = 0; i < list.size(); i++) {
            StackNode treeNode = (StackNode) list.get(i);

            treeNode.printNonRoot(out, depth + 1);
        }
    }

    // ---------------------------------------------------------------

    public synchronized void reset() {

        // need to clone map - concurrency issues
        List list = new ArrayList();

        synchronized (children) {
            list.addAll(children.values());
        }

        for (int i = 0; i < list.size(); i++) {
            StackNode treeNode = (StackNode) list.get(i);

            treeNode.reset();
        }

        super.reset();  // this is the actual call to reset
    }


}
